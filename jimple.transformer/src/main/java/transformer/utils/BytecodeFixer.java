package transformer.utils;

import java.util.Map;
import java.util.Stack;

import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import sootup.core.jimple.basic.Local;

/**
 * BytecodeFixer class ensures that local variables and stack management are correctly handled.
 */
public class BytecodeFixer {

    private static final Logger logger = LoggerFactory.getLogger(BytecodeFixer.class);

    // Stack to track the operand stack content during bytecode generation
    private final Stack<String> operandStack = new Stack<>();

    /**
     * Fixes local variable references and stack misalignments in the generated bytecode.
     *
     * @param mv          The MethodVisitor used to generate bytecode.
     * @param indexMapper The LocalIndexMapper used to track local variables.
     */
    public void fixBytecode(MethodVisitor mv, LocalIndexMapper indexMapper) {
        logger.info("Starting bytecode fixing process...");

        // Iterate over local variables and ensure proper stack and local assignments
        for (Map.Entry<Local, Integer> entry : indexMapper.getLocalIndexMap().entrySet()) {
            Local local = entry.getKey();
            int index = entry.getValue();

            // Get the local variable type
            String localType = local.getType().toString();

            // Adjust the load/store operation based on type and stack state
            if (localType.equals("int") || localType.equals("boolean") || localType.equals("char") || localType.equals("byte") || localType.equals("short")) {
                fixPrimitiveLoadStore(mv, index, Opcodes.ILOAD, Opcodes.ISTORE);
            } else if (localType.equals("float")) {
                fixPrimitiveLoadStore(mv, index, Opcodes.FLOAD, Opcodes.FSTORE);
            } else if (localType.equals("double")) {
                fixPrimitiveLoadStore(mv, index, Opcodes.DLOAD, Opcodes.DSTORE);
            } else if (localType.equals("long")) {
                fixPrimitiveLoadStore(mv, index, Opcodes.LLOAD, Opcodes.LSTORE);
            } else {
                fixReferenceLoadStore(mv, index);
            }
        }

        // Final stack cleanup if necessary
        if (!operandStack.isEmpty()) {
            logger.warn("Unbalanced stack detected. Fixing stack...");
            while (!operandStack.isEmpty()) {
                operandStack.pop();
                mv.visitInsn(Opcodes.POP);
            }
        }

        logger.info("Bytecode fixing process completed.");
    }

    /**
     * Correctly loads and stores reference types (e.g., objects) based on the stack state.
     */
    private void fixReferenceLoadStore(MethodVisitor mv, int index) {
        logger.info("Checking reference variable at index: " + index);
        if (operandStack.isEmpty()) {
            mv.visitVarInsn(Opcodes.ALOAD, index);
            operandStack.push("object");
        } else {
            mv.visitVarInsn(Opcodes.ASTORE, index);
            operandStack.pop();
        }
    }

    /**
     * Ensures correct handling of primitive types like int, float, etc.
     */
    private void fixPrimitiveLoadStore(MethodVisitor mv, int index, int loadOpcode, int storeOpcode) {
        if (operandStack.isEmpty()) {
            mv.visitVarInsn(loadOpcode, index);
            operandStack.push("primitive");
        } else {
            mv.visitVarInsn(storeOpcode, index);
            operandStack.pop();
        }
    }
}
